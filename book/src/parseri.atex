@chapter{Parseri}

@p @def{Parser} je funkcija koja od niza nekih simbola generiÅ¡e vrednosti. NajÄeÅ¡Ä‡e parseri sluÅ¾e da se niske (liste karaktera) transformiÅ¡u u neke vrednosti poput brojeva ili struktura podataka.

@example{
@p Funkcija @code{read :: Read a => String -> a} koja "Äita" vrednost iz niske, nije niÅ¡ta drugo nego jedan parser.

@terminal{
ghci> read "39.5" :: Float
39.5
ghci> read "[True, False]" :: [Bool]
[True, False]
}
}

@example{
@p I sami smo konstruisali jedan parser u lekciji o listama. U pitanju je funkcija @code{uBroj :: [Char] -> Int} koja iz niske parsira brojeve.
}

@p Parsiranje je generalno teÅ¾ak problem. Stoga ne Äudi Å¡to je tokom istorije raÄunarstva razvijeno mnogo teorije o parserima i konkretnim tehnikama za njihovo konstruisanje. Svakako, teorija o parserima prevazilazi obime ove knjige, ali moÅ¾emo ovde prikazati jednu tehniku za konstrukciju parsera. U pitanju su takozvani @def{parser kombinatori} koji su zapravo funkcije viÅ¡eg reda kojima se jednostavniji parseri kombinuju u sloÅ¾enije.

@section{Tip parsera}

@p Parsiranjem bi trebalo nisku (koja je lista karaktera) pretvoriti u neku vrednost tipa @code{T}. Na primer, parser celobrojnih brojeva bi trebalo da nisku transformiÅ¡e u vrednost tipa @code{Int}, pa bi tip ovakvog parsera bio @code{String -> Int}. Parser logiÄkih lista bi trebalo da nisku pretvori u vrednost tipa @code{[Bool]}, pa bi tip ovakvog parsera bio @code{String -> [Bool]}. Stoga Ä‡emo definisati novi (apstraktni) tip @ccode{Parser a = String -> a}, koji moÅ¾e predstaviti parsere za vrednosti bilo kog tipa. MeÄ‘utim, kroz ovaj novi tip je neophodno obezbediti joÅ¡ par stvari. 

@list{
@li Prvo, neÄ‡emo svaki parser konstruisati kao jedinstvenu funkciju. SloÅ¾enije parsere Ä‡emo konstruisati kombinovanjem manjih funkcija. Svaka od tih funkcija parsiraÄ‡e jedan karakteristiÄan deo niske (Na primer, parser @code{Float} vrednosti moÅ¾e biti saÄinjen od tri parsera: prvog koji parsira ceo deo, drugog koji parsira taÄku, i treÄ‡eg koji parsira razlomljeni deo. SliÄno, parser logiÄkih nizova moÅ¾e biti saÄinjen od parsera koji parsira zagrade, parsera za literale logiÄke vrednosti, parsera za zarez, parsera za beline, itd...). Parsere Ä‡emo kombinovati tako Å¡to Ä‡e svaki naredni parser, parsirati ono "Å¡to ostane" nakon pokretanja prethodnih parsera. Stoga jedan parser vrednosti @code{T} neÄ‡e vraÄ‡ati samo vrednost tipa @code{T}, veÄ‡ ureÄ‘en par tipa @code{(T, String)}, gde druga koordinata oznaÄava ostatak niske koja se parsira.
@li Drugo, ne moÅ¾emo oÄekivati da Ä‡e svako parsiranje biti uspeÅ¡no. Iz niske @code{"Hi!"} ne moÅ¾emo parsirati broj niti logiÄku listu. Zbog toga, parser Ä‡e zapravo vratiti moÅ¾da-vrednost @code{Maybe (T, String)}. Ako je parser uspeo, rezultat je oblika @code{Just (x, s)} za neku nisku @code{s} i vrednost @code{x :: T}. U suprotnom, parser vraÄ‡a @code{Nothing}.  
}

@p UzimajuÄ‡i prethodno u obzir, stiÅ¾emo do definicije tipa

@codeBlock{
newtype Parser a = P (String -> Maybe (a, String))
}{Od sada, parser celih brojeva je tipa @code{Parser Int}, a parser lista logiÄkih vrednosti je tipa @code{Parser [Bool]}, itd...}

@p Sa navedenom definicijom tipa biÄ‡e zgodna funkcija koja "pokreÄ‡e" parser nad niskom:

@codeBlock{
parsiraj :: Parser a -> String -> Maybe (a, String)
parsiraj (P p) s = p s 
}


@p Kreirajmo parser koji parsira jedno slovo iz niske. Taj parser ima tip @code{Parser Char}. Sa konstruktorom @code{P} obuhvatiÄ‡emo funkciju koja uzima jedno slovo sa poÄetka niske. Ako je niska prazna, parser Ä‡e vratiti @code{Nothing}.

@codeBlock{
slovo :: Parser Char
slovo = P f
    where
        f [] = Nothing
        f (x:xs) = Just (x, xs)
}{Lokalno definisana funkcija @code{f} vrÅ¡i glavnu ulogu. MeÄ‘utim, da bi dobili vrednost tipa @code{Parse Char}, neophodno je da "upakujemo" ovu funkciju u konstruktor @code{P}. Naravno, postavlja se pitanje zaÅ¡to je bilo neophodno da definiÅ¡emo novi tip a ne tipski sinonim koji koji ne bi zahtevao konstruktor. Razlog tome je Å¡to za novi tip moÅ¾emo definisati instance klasa @code{Functor} i @code{Applicative}, Å¡to nije moguÄ‡e sa tipskim sinonimom koji se odnosi na tip funkcije.}

@p Testiranje parsera je veoma jednostavno (i veoma Äitljivo!):

@terminal{
ghci> parsiraj slovo "Hello world!"
Just ('H', "ello world!")
ghci> parsiraj slovo ""
Nothing
}

@p Nakon slova, najprirodnije je kreirati parser cifre. Parser cifre treba da nam vrati numeriÄku vrednost cifre, ako ulazna niska poÄinje sa cifrom.

@codeBlock{
cifra :: Parser Int
cifra = P f where
    f []     = Nothing
    f (x:xs) =
        if x `elem` ['1' .. '9']
        then Just (romEnum x - fromEnum '0', xs)
        else Nothing
}{Tip karaktera pripada klasi @code{Enum}, te je moguÄ‡e koristiti funkciju @code{fromEnum} koja daje @em{ASCII} vrednost karaktera. Oduzimanjem te vrednosti od @em{ASCII} vrednosti karaktera @code{'0'}, dobijamo numeriÄku vrednost koju niska predstavlja.}

@terminal{
ghci> parsiraj cifra "9abc"
Just (0, "abc")
ghci> parsiraj cifra "1234"
Just (1, "234")
ghci> parsiraj cifra "Hello!"
Nothing
}

@problem{Kreirati funkciju @code{maloSlovo :: Parser Char} koja parsira samo mala latiniÄna slova (tj. karakter iz raspona @code{['a' .. 'w']}).}


@p ÄŒesto je zgodno da kreiramo funkciju koja kreira nekakav parser na osnovu prosleÄ‘enih argumenata. Parser @code{simbol :: Char -> Parser Char} je primer takve funkcije. Funkcija @code{simbol} uzima jedan karakter i vraÄ‡a parser koji parsira iskljuÄivo taj karakter, a za sve ostale karaktere podbacuje.

@codeBlock{
simbol :: Char -> Parser Char
simbol c = P $ \s -> case s of
    x:xs -> if x == c then Just (c, xs) else Nothing
    _   -> Nothing
}

@terminal{
ghci> parsiraj (simbol 'H') "Hello!"
Just ('H', "ello!")
ghci> parsiraj (simbol 'A') "Hello!"
Nothing
}


@problem{Kreirati funkciju @code{niska :: String -> Parser String} koja na osnovu niske @code{s} kreira parser koji parsira iskljuÄivo @code{s}.}


@section{Kombinatori}

@p Parseri koje smo do sad konstruisali su bili "atomiÄki". Za kreiranje sloÅ¾enijih parsera, poput onih koji parsiraju Äitav kÃ´d nekog programskog jezika, potrebno je jednostavnije parsere ukombinovati u sloÅ¾enije. Takvo kombinovanje vrÅ¡imo pomoÄ‡u funkcija koje nazivamo @def{parser kombinatori}. Parser kombinatori o postojeÄ‡ih parsera prave nove parsere.

@p Verovatno najjednostavniji, netrivijalni, parser kombinator je kombinator koji na uspeÅ¡an rezultat nekog parsera primenjuje datu funkciju @code{f}:

@codeBlock{
primeni :: (a -> b) -> Parser a -> Parser b
primeni f p = P $ 
        \s -> case p s of
            Just (x, s') -> Just (f x, s')
            Nothing -> Nothing
}

@example{
@p ImaÄ‡emo prilike da se uverimo u narednom primerima zaÅ¡to je @code{primeni} koristan, a sada dajemo jedan jednostavan primer da bi demonstrirali kako ovaj kombinator funkcioniÅ¡e. Primenom funkcije @m{f(x) = x^2} na parser cifre, dobijamo parser koji sa poÄetka niske parsira kvadrat cifre.

@terminal{
ghci> kvadrat = primeni (\x -> x*x) cifra
ghci> kvadrat "3"
Just (9, "")
}
}

@p Veoma koristan je parser kombinator @em{ili}, koji uzima dva parsera i kreira novi parser koji pokuÅ¡ava da pokrene prvi parser a sluÄaju neuspeha i drugi parser. Ovakav kombinator ima sasvim jednostavnu definiciju:

@codeBlock{
ili :: Parser a -> Parser a -> Parser a
ili p1 p2 = P $ 
        \s -> case parsiraj p1 s of
            Just (v, s') -> Just (v, s')
            Nothing -> parsiraj p2 s
}

@example{
@p KoristeÄ‡i kombinator @code{ili} moÅ¾emo lako napraviti parser koji parsira samo simbole @pre{x} i @pre{o}:

@terminal {
ghci> iksoks = ili (simbol 'x') (simbol 'o')
ghci> parsiraj iksoks "xoxox"
Just ("x","oxox")
ghci> parsiraj iksoks "aaaa"
Nothing
}

@p Kombinator @code{ili} je veoma zgodno postaviti u infiksni oblik. tako smo mogli da definiÅ¡emo @ccode{iksoks = (simbol 'x') `ili` (simbol 'o')}. Iako moÅ¾da deluje neobiÄno, ovakva sintaksa doprinosi Äitljivosti jer zapis podseÄ‡a na prirodne reÄenice: @em{parsirati simbol "x" ili simbol "o"}.
}

@problem{Napisati parser koji koji simbole @pre{x} i @pre{o} parsira kao logiÄke vrednosti @code{True} i @code{False}.}

@p Do sada smo parsirali samo jedinstvene vrednosti. Sada Ä‡emo konstruisati parser kombinator tipa @code{Parser a -> Parser [a]} koji parsira listu vrednosti istog tipa, tako Å¡to pokreÄ‡e prosleÄ‘eni parser dokle god moÅ¾e. Nazovimo ovaj kombinator @code{viÅ¡e} jer rezultat (moÅ¾e) sadrÅ¾ati viÅ¡e vrednosti istog tipa. Definicija kombinatora mora sadrÅ¾ati rekurzivne pozive, Å¡to Ä‡emo uspostaviti sa pomoÄ‡nom rekurzivnom funkcijom @code{r}:

@codeBlock{
viÅ¡e :: Parser a -> Parser [a]
viÅ¡e (P f) = P $ \s -> (Just r s)
    where
        r [] = []
        r xs = case f xs of
            Just (v, xs') -> v : r xs'
            Nothing       -> []
}

@problem{Konstruisati kombinator @code{zatim :: Parser a -> Parser b -> Parser (a , b)}, koji pokreÄ‡e prvi a zatim i drugi parser, i vraÄ‡a ureÄ‘en par rezultat parsiranja.}

@problem{Parser @code{viÅ¡e p} moÅ¾e da vrati i praznu listu kao uspeÅ¡nu vrednost Å¡to Äesto nije poÅ¾eljno. Definisati kombinator @code{baremJedan :: Parser a -> Parser [a]}, koji mora da parsira barem jednu vrednost (tj, nikad neÄ‡e vratiti praznu listu).}{
@p Umesto da direktno napiÅ¡emo definiciju kombinatora, iskoristiÄ‡emo postojeÄ‡e kombinatore. Ako je dat parser @code{p :: Parser A}, tada parser @ccode{p `zatim` (viÅ¡e p)} parsira vrednost tipa @code{(A, [A])}. Stoga je dovoljno sa kombinatorom @code{primeni} spojiti ove dve ove koordinate u jednu listu sa funkcijom @code{\(x,xs) -> x:xs} (ovo je naravno funkcija @code{uncurry (:)}). Prema tome, moÅ¾emo definisati @ccode{baremJedan p = primeni (uncurry (:)) (p `zatim` (viÅ¡e p))}.}

@p Sada kada smo se upoznali sa najvaÅ¾nijim parser kombinatorima, moÅ¾emo lako konstruisati jedan veoma koristan parser. U pitanju je parser celobrojnih vrednosti. UspeÅ¡ni pokretanjem parsere @ccode{viÅ¡e cifra} dobijamo vrednost tipa @code{[Int]} koja predstavlja cifre sa poÄetka ulazne niske. Stoga je dovoljno napisati funkciju @code{cifreUBroj :: [Int] -> Int} koja Ä‡e niz cifara svesti na broj. Naravno, ovde nam je potreban rekurzivan prolazak kroz listu, pri Äemu Ä‡emo Äuvati "trenutnu vrednost" koja se pri svakom koraku uveÄ‡ava 10 puta (tj za jedno decimalno mesto). Direktna implementacija@note{Jednostavnije, funkciju @code{cifreUBroj} smo mogli da definiÅ¡emo i kao @ccode{foldl (\a x -> 10*a + x) 0} odnosno joÅ¡ kraÄ‡e @ccode{foldl ((+) . (*10)) 0}} izgleda ovako:

@codeBlock{
cifreUBroj :: [Int] -> Int
cifreUBroj xs =  r 0 xs where
    r v []     = v
    r v (x:xs) = r (10 * v + x) xs
}

@p Sada, parser @code{broj :: Parser Int} moÅ¾e da se definiÅ¡e kao @ccode{broj = primeni cifreUBroj $ viÅ¡e cifra}.

@terminal{
ghci> parsiraj broj "123abc456"
Just (123, "abc456")
ghci> parsiraj broj "abc"
0
}{Umesto @code{viÅ¡e} moÅ¾emo da iskoristimo kombinator @code{baremJedan} da bi dobili @code{Nothing} ako ulazna niska ne poÄinje sa brojem.}

@problem{Konstruisati parser celobrojnih vrednosti bez koriÅ¡Ä‡enja kombinatora.}

@section{Aplikativni parseri}

@p Tip funkcije @ccode{primeni :: (a -> b) -> Parser a -> Parser b} neodoljivo podseÄ‡a na tip metode @ccode{fmap :: Functor Ï† => (a -> b) -> Ï† a -> Ï† b} sa kojom smo se upoznali i lekciji o funktorima. Kako je i tip @code{Parser} jedan apstraktni tip vrste @code{* -> *} ima smisla instancirati @code{Functor Parser} koristeÄ‡i istu definiciju koju smo dali za @code{primeni}

@codeBlock{
instance Functor Parser where
    fmap f p = P $
        \s -> case p s of
            Just (x, s') -> Just (f x, s')
            Nothing -> Nothing
}{Rezultat "mapiranja" funkcije @code{f} na neki parser @code{p}, je novi parser koji na uspeÅ¡an rezultat parsiranja parsera @code{f} primenjuje funkciju @code{f}.}

@p Sada je neophodno dokazati da ovako data definicija zadovoljava dva zakona.

@p Prvo, za svaki parser @code{p} mora vaÅ¾iti da je @ccode{fmap id p = p}. Kako je parser @code{p} oblika @code{P p'} za neku funkciju @code{p'}, vaÅ¾i sledeÄ‡e @ccode{fmap id p = fmap id (P p')} @ccode{= P $ \s -> case p' s of ğ• (x, s') -> ğ• (id x, s'); â„• -> â„•} @ccode{= P $ \s -> case p' s of ğ• (x, s') -> ğ• (x, s'); â„• -> â„•} @ccode{= P p' = p}, gde smo sa @code{ğ•} i @code{â„•} skraÄ‡eno oznaÄili konstruktore @code{Just} i @code{Nothing}. Ovim je prvi zakon dokazan.

@p Za dokaz drugog zakona, neka su date funkcije @code{f :: A -> B} i @code{g :: B -> C}. Tada za svaki parser @code{p = P p' :: Parser A} vaÅ¾i @ccode{fmap (g . f) p = fmap (g . f) (P p')}
@ccode{= P $ \s -> case p' s of ğ• (x, s') -> ğ• ((g . f) x, s'); â„• -> â„•}
@ccode{= P $ \s -> case p' s of ğ• (x, s') -> ğ• (g (f x), s'); â„• -> â„•}
@ccode{= fmap g $ P $ \s -> case p' s of ğ• (x, s') -> ğ• (f x, s'); â„• -> â„•}
@ccode{= fmap g $ fmap f $ P $ \s -> case p' s of ğ• (x, s') -> ğ• (x, s'); â„• -> â„•}
@ccode{= fmap g $ fmap f $ P p'}
@ccode{= (fmap g . fmap f) p},
Äime je dokazan i drugi zakon funktora.

@p SledeÄ‡i korak je implementirati instancu @code{Applicative Parser}. Za metodu @code{pure :: a -> Parser a}, nemamo mnogo izbora: to Ä‡e biti "konstantan" parser koji ne parsira niÅ¡ta. Za metodu @ccode{<*> :: Parser (a -> b) -> Parser a -> Parser b} takoÄ‘e nemamo mnogo opcija. Ako nam je dat parser @code{p1 :: Parser (A -> B)} i parser @code{p2 :: Parser A}, sve Å¡to moÅ¾emo da uradimo da bi dobili vrednost @code{B} je da "pokrenemo" parser @code{p1} i onda sa dobijenim vrednostima "pokrenemo" parser @code{p2}. Naravno, ako neki od parsera ne uspe, tada ni "kombinacija" ovih parsera ne bi trebalo da uspe.

@codeBlock{
instance Applicative Parser where
    pure x = P $ \s -> Just (s, x)

    p1 <*> p2 = P $ \s -> primeni (parsiraj p1 s) p2
        where
            primeni Nothing       _ = Nothing
            primeni (Just (s',f)) p = parsiraj (fmap f p) s'
}{PomoÄ‡na funkcija @code{primeni}, proverava da li je parsiranje sa @code{p1} uspelo. Ako jeste uspelo, tada se rezultat @code{(s', f)} prosleÄ‘uje parseru @code{p2}, tako Å¡to se parser @code{fmap f p1} pokreÄ‡e nad ostatkom @code{s'}.}

@problem{Dokazati da navedena definicija poÅ¡tuje zakone aplikativnih funktora.}

@p Parseri koji parsiraju funkciju (tj. vrednosti tipa oblika @code{Parser (A -> B)}) su na prvi pogled veoma Äudan pojam. Å ta uopÅ¡te znaÄi parsirati funkciju iz niske karaktera? Ali, setimo se koja je bila motivacija za uvoÄ‘enje aplikativnih funktora: aplikacija funkcija viÅ¡e promenljiva na vrednosti u funktorima. Od sada koristeÄ‡i @code{pure} i @code{<*>} moÅ¾emo kombinovati parsere koristeÄ‡i proizvoljne funkcije.

@example{
@p Kreirajmo parser koji parsira jedno slovo, zatim cifru i zatim te dve vrednosti kombinuje u ureÄ‘eni par. Iz prethodnih primera i zadataka imamo parsere @code{slovo :: Parser Char} i @code{cifra :: Parser Int}, a Å¾elimo parser @code{slovoCifra :: Parser (Char, Int)}.

@p Funkcija @ccode{f = \x y -> (x, y) :: a -> b -> (a, b)} kombinuje dve vrednosti u ureÄ‘en par@note{Ovu funkciju kraÄ‡e moÅ¾emo zapisati kao konstruktor ureÄ‘enog para @code{(,)}.}. Stoga, vrednost @code{pure f :: Parser (a -> b -> (a, b))} je moguÄ‡e sa operatorom@note{PodseÄ‡amo da je @code{<*>} levoasocijativan operator.} @code{<*>} primeniti na dve vrednosti tipa @code{Parser A} i @code{Parser B}, da bi dobili vrednost @code{Parser (A, B)}. I zaista

@terminal{
ghci> f = \x y -> (x, y)
ghci> slovoCifra = f <$> slovo <*> cifra
ghci> parsiraj slovoCifra "D7"
Just (('D',7), "")
}{Idealno za parsiranje oznaka Å¡ahovskih polja!}
}


@p Kako operatori @code{<*} i @code{*>} funkcioniÅ¡u u kontekstu parsera? Po definiciji, operator @ccode{(<*) :: Parser a -> Parser b -> Parser a} je definisan kao @ccode{p1 <* p2 = liftA2 const p1 p2} Å¡to se svodi na @ccode{p1 <* p2 = (fmap const p1) <*> p2}. Ako je @code{p1 :: Parser A}, tada je @code{fmap const p1 :: Parser (a -> Int)} parser koji je moguÄ‡e primeniti sa @code{<*>} na bilo koji drugi parser, ali Ä‡e parsirana vrednost zavisiti samo od parsera @code{p1}, dok Ä‡e parsirana vrednost parsera @code{p2} biti ignorisana, pod uslovom da parser @code{p2} uspe. Ako parser @code{p2} nije uspeÅ¡an, tada Ä‡e i parser @code{p1 <* p2} podbaciti. SliÄno je i sa operatorom @ccode{ (*>) :: f a -> f b -> f b} koji ignoriÅ¡e rezultat levog parsera (pod uslovom da je taj parser uspeo).

@p Navedeni operatori nam omoguÄ‡avaju da konstruiÅ¡emo parsere koji moraju parsirati neke delove niske, ali ti delovi ne utiÄu na parsiranu vrednost. Primer za ovu situaciju je parsiranje brojeva sa decimalnom taÄkom: taÄka se mora naÄ‡i u zapisu decimalnog broja, ali ne utiÄe nikako na vrednost tog broja.

@example{
@p ImitirajuÄ‡i ideju o rekurzivnoj primeni parsera, moÅ¾emo na jednostavan naÄin implementirati funkciju @ccode{niska :: String -> Parser String} koju smo spomenuli u prethodnom zadatku.

@p Prvo, parsiranje prazne niske iz bilo koje druge niske uvek treba da uspe. Ovo predstavlja bazni sluÄaj. Drugo, parsiranje neke niske @code{x:xs} iz niske @code{s} moÅ¾e da se izvede tako Å¡to se prvo parsira simbol @code{x}, pa ako to parsiranje uspe, rekurzivno se parsira i ostatak @code{xs}:

@codeBlock{
niska :: String -> Parser String
niska ""     = P $ \s -> Just (s, "")
niska (x:xs) = P $ \s -> case parsiraj (simbol x) s of
    Just (s',_) -> parsiraj ((x:) <$> niska xs) s'
    Nothing     -> Nothing
}

@terminal{
ghci> parsiraj (niska "True") "Truehelloworld"
Just ("helloworld","True")
ghci> parsiraj (niska "False") "Falsebyeworld"
Just ("byeworld","False")
ghci> parsiraj (niska "hello") "bye"
Nothing
}
}

@problem{Definisati parser @code{decimalanBroj :: Parser Float} koji parsira broj oblika @eq{\overline{a_1\cdots a_n .b_1\cdots b_m}.}}

@problem{
Definisati parser @ccode{logiÄkeListe :: Parser [Bool]} koji parsira liste logiÄkih vrednosti @code{True} i @code{False}. Na primer, parser bi trebalo da ispravno parsira nisku @code{"[True,False]"}. Pretpostaviti da u nisci neÄ‡e biti belina.
}

@problem{
Definisati parser @ccode{preskoÄiBeline :: Parser ()} koji samo preskaÄe karaktere beline @code{' '}, @code{'\n'} i @code{'\t'}.
}

@problem{Ponovo definisati parser @code{logiÄkeListe :: Parser [Bool]} ali tako da ispravno parsira niske u kojima se nalaze beline izmeÄ‘u logiÄkih vrednosti i zareza ili zagrada. Na primer, parser bi trebalo da ispravno parsira nisku poput @ccode{"[  True,    False ]"}.}

@section{Parsiranje matematiÄkih izraza}

@p U lekciji o rekurzivnim strukturama podataka, definisali smo tip @code{Izraz} ka algebarski tip @ccode{data Izraz = Broj Int | Zbir Izraz Izraz | Proizvod Izraz Izraz}. TakoÄ‘e smo i definisali instancu @code{Show Izraz} na sasvim jednostavan naÄin.

@codeBlock{
instance Show Izraz where
    show (Broj a) = show a
    show (Zbir a b) = "(" ++ show a ++ "+" ++ show b ++ ")"
    show (Proizvod a b) = "(" ++ show a ++ "*" ++ show b ++ ")"
}

@p Kako to obiÄno biva, obrnuti proces, proces Äitanja strukture iz niske, je znaÄajno komplikovaniji za implementaciju, ali nam tehnika aplikativnih parsera moÅ¾e nam pomoÄ‡i u ovom sluÄaju. Sa parserom kog budemo konstruisali, moÄ‡i Ä‡emo da iz niske proÄitamo vrednost @code{Izraz}.

@p Pre nego Å¡to poÄnemo sa definisanjem parsera, moramo taÄno definisati oblik niska koje Ä‡emo parsirati. Na primer, sloÅ¾eni parseri izraza mogu ispravno parsirati izraze poput @code{"2 +  5"} ili @code{"2*-7+6"} jer su napravljeni tako da ignoriÅ¡u beline (razmake), da vode raÄuna o prioritetu operacija, podrÅ¾avaju unarni operator negacije, itd... Da bismo skratili naredne redove, mi neÄ‡emo kreirati ovako sloÅ¾eni parser. Parser koji budemo konstruisali moÄ‡i Ä‡e da parsira samo one izraze koji su nastali sa funkcijom @code{show :: Izraz -> String} koju smo gore definisali tj, izraze saÄinjene iskljuÄivo od cifara i znakova @code{+}, @code{-}, @code{(}, @code{)}, pri Äemu se oko svakog podizraza nalaze zagrade (osim oko samih brojeva).
  
@p Kako je i sama struktura tipa @code{Izraz} rekurzivna, i parser tipa @code{Parser Izraz} biÄ‡e rekurzivan. Posebno Ä‡emo konstruisati parser @code{izrazBroj} koji parsira brojeve, parser @code{izrazZbir} koji parsira zbir dva manja izraza, i parser @code{izrazProizvod} koji parsira proizvod dva manja izraza.

@p Pretpostavimo da su navedeni parseri definisani. Jedan izraz moÅ¾e biti broj, proizvod ili zbir manjih izraza. Zbog toga, da bi parsirali izraz, prvo Ä‡emo pokuÅ¡ati da parsiramo broj. Ako to ne uspemo, onda Ä‡emo pokuÅ¡ati da parsiramo zbir, a ako ni to ne uspemo pokuÅ¡aÄ‡emo da parsiramo proizvod@note{Pritom, ovde uopÅ¡te nije bitno kojim redom pokuÅ¡avamo pa pokrenemo parsere. U sloÅ¾enijim parserima, poredak je Äesto bitan}. Sa kombinatorom @code{ili} lako dobijamo Å¾eljeni parser:

@codeBlock{
izraz :: ParserIzraz
izraz = izrazBroj `ili` izrazZbir `ili` izrazProizvod
}

@p Ostaje joÅ¡ definisati @code{izrazBroj}, @code{izrazZbir} i @code{izrazProizvod}. Parser @code{izrazBroj} Ä‡emo lako definisati pomoÄ‡u parsera @code{broj :: Parser Int} kog posedujemo od ranije. Sve Å¡to je potrebno je da parsiranu vrednost (koja je tipa @code{Int}), transformiÅ¡emo u vrednost tipa @code{Izraz}, Å¡to se naravno postiÅ¾e podizanjem konstruktora @code{Broj :: Int -> Izraz} na nivo funktora @code{Parser}:

@codeBlock{
izrazBroj :: Parser Izraz
izrazBroj = fmap Broj broj
}

@p Parser @code{izrazZbir} mora da funkcioniÅ¡e na sledeÄ‡i naÄin: prvo je neophodno parsirati simbol za levu zagradu, zatim je potrebno parsirati levi sabirak, pa simbol plus, desni sabirak, i na kraju simbol desne zagrade. Rezultati parsiranja simbola nisu bitni (ako su uspeÅ¡ni), a rezultate parsiranja levog i desnog sabirka moramo ukombinovati u vrednost oblika @code{Zbir x y :: Izraz}. Naravno, u tome Ä‡e nam pomoÄ‡i podizanje konstruktora @code{Zbir}. TakoÄ‘e, kako su oba sabirka izrazi sami za sebe, potrebno ih je parsirati sa @code{izraz} parserom. Ovo uspostavlja rekurziju.

@codeBlock{
izrazZbir :: Parser Izraz
izrazZbir =
    simbol '(' *>
    (Zbir <$> (izraz <* simbol '+') <*> izraz)
    <* simbol ')' 
}

@p Parsiranje proizvoda je u potpunosti analogno parsiranju zbira:

@codeBlock{
izrazProizvod :: Parser Izraz
izrazProizvod = 
    simbol '(' *>
    (Proizvod <$> (izraz <* simbol '*') <*> izraz)
    <* simbol ')' 
}

@p Testiranjem se uveravamo da parser funkcioniÅ¡e:

@terminal{
ghci> parsiraj izraz "(1+2)"
Just ((1+2), "")
ghci> parsiraj izraz "((10+2)*32)"
Just (((10+2)*32), "")
}{Vrednost koju vidimo u prvoj koordinati je sintaksno stablo. Zbog naÄina na koje smo definisali @code{show}, ovo sintaksno stablo se prikazuje na sasvim jednostavan naÄin.}
